{
  "name": "ChainMesh - API Gateway",
  "nodes": [
    {
      "id": "a1b2c3d4-0001-4000-8000-000000000001",
      "name": "Webhook POST /api/query",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "chainmesh-api-query",
      "parameters": {
        "path": "api/query",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {
          "rawBody": false
        }
      }
    },
    {
      "id": "a1b2c3d4-0001-4000-8000-000000000002",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [480, 300],
      "parameters": {
        "jsCode": "// Validate the incoming query request against GenericQueryRequest schema\nconst body = $input.first().json.body;\n\nconst SUPPORTED_CHAINS = ['sepolia', 'arbitrum', 'base', 'optimism'];\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\nconst ADDRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;\n\nconst errors = [];\n\n// key: required bytes32\nif (!body.key || !BYTES32_REGEX.test(body.key)) {\n  errors.push({ field: 'key', message: 'Must be a valid bytes32 hex string (0x + 64 hex chars)' });\n}\n\n// schemaHash: required bytes32\nif (!body.schemaHash || !BYTES32_REGEX.test(body.schemaHash)) {\n  errors.push({ field: 'schemaHash', message: 'Must be a valid bytes32 hex string (0x + 64 hex chars)' });\n}\n\n// chains: required non-empty array of supported chains\nif (!Array.isArray(body.chains) || body.chains.length === 0) {\n  errors.push({ field: 'chains', message: 'At least one chain is required' });\n} else {\n  for (const chain of body.chains) {\n    if (!SUPPORTED_CHAINS.includes(chain)) {\n      errors.push({ field: 'chains', message: `Unsupported chain: ${chain}. Supported: ${SUPPORTED_CHAINS.join(', ')}` });\n    }\n  }\n}\n\nif (errors.length > 0) {\n  return [{ json: { valid: false, errors } }];\n}\n\n// Build validated request with defaults\nconst validated = {\n  key: body.key,\n  schemaHash: body.schemaHash,\n  chains: body.chains,\n  includeAnalysis: body.includeAnalysis !== undefined ? Boolean(body.includeAnalysis) : true,\n  options: {\n    timeoutMs: body.options?.timeoutMs ?? 180000,\n    fallbackProviders: body.options?.fallbackProviders ?? true,\n    ...(body.options?.customConfig ? { customConfig: body.options.customConfig } : {})\n  },\n  ...(body.metadata ? {\n    metadata: {\n      ...(body.metadata.messageId ? { messageId: body.metadata.messageId } : {}),\n      ...(body.metadata.sourceChain ? { sourceChain: body.metadata.sourceChain } : {}),\n      ...(body.metadata.requester ? { requester: body.metadata.requester } : {})\n    }\n  } : {})\n};\n\n// Validate optional metadata fields format\nif (validated.metadata?.messageId && !BYTES32_REGEX.test(validated.metadata.messageId)) {\n  errors.push({ field: 'metadata.messageId', message: 'Must be a valid bytes32 hex string' });\n}\nif (validated.metadata?.requester && !ADDRESS_REGEX.test(validated.metadata.requester)) {\n  errors.push({ field: 'metadata.requester', message: 'Must be a valid Ethereum address' });\n}\n\n// Validate timeoutMs range\nif (validated.options.timeoutMs < 10000 || validated.options.timeoutMs > 300000) {\n  errors.push({ field: 'options.timeoutMs', message: 'Must be between 10000 and 300000 ms' });\n}\n\nif (errors.length > 0) {\n  return [{ json: { valid: false, errors } }];\n}\n\nreturn [{ json: { valid: true, request: validated } }];"
      }
    },
    {
      "id": "a1b2c3d4-0001-4000-8000-000000000003",
      "name": "Validation OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [720, 300],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-valid",
              "leftValue": "={{ $json.valid }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        }
      }
    },
    {
      "id": "a1b2c3d4-0001-4000-8000-000000000004",
      "name": "Respond 400 Bad Request",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [960, 480],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ statusCode: 400, error: { type: 'VALIDATION_ERROR', message: 'Input validation failed', details: $json.errors } }) }}",
        "options": {
          "responseCode": 400,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      }
    },
    {
      "id": "a1b2c3d4-0001-4000-8000-000000000005",
      "name": "Call GenericOrchestrator",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [960, 300],
      "parameters": {
        "source": "parameter",
        "workflowId": "={{ $env.ORCHESTRATOR_WORKFLOW_ID }}",
        "options": {
          "waitForSubWorkflow": true
        }
      }
    },
    {
      "id": "a1b2c3d4-0001-4000-8000-000000000006",
      "name": "Format Success Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 200],
      "parameters": {
        "jsCode": "const result = $input.first().json;\n\nreturn [{\n  json: {\n    statusCode: 200,\n    data: {\n      key: result.context?.input?.key,\n      schemaHash: result.context?.input?.schemaHash,\n      executionId: result.executionId,\n      result: {\n        providerOutput: result.data?.providerOutput,\n        analyzerOutput: result.data?.analyzerOutput,\n        signerOutput: result.data?.signerOutput,\n        txHash: result.data?.txHash,\n        isFromCache: false,\n        timestamp: new Date().toISOString()\n      }\n    }\n  }\n}];"
      }
    },
    {
      "id": "a1b2c3d4-0001-4000-8000-000000000007",
      "name": "Format Error Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 400],
      "parameters": {
        "jsCode": "const result = $input.first().json;\n\nreturn [{\n  json: {\n    statusCode: 500,\n    error: {\n      type: result.error?.type || 'EXECUTION_ERROR',\n      message: result.error?.message || 'Unknown execution error',\n      executionId: result.executionId,\n      step: result.error?.step\n    }\n  }\n}];"
      }
    },
    {
      "id": "a1b2c3d4-0001-4000-8000-000000000008",
      "name": "Orchestrator Success?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1200, 300],
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-success",
              "leftValue": "={{ $json.success }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        }
      }
    },
    {
      "id": "a1b2c3d4-0001-4000-8000-000000000009",
      "name": "Respond 200 OK",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1440, 200],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      }
    },
    {
      "id": "a1b2c3d4-0001-4000-8000-000000000010",
      "name": "Respond 500 Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1440, 400],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {
          "responseCode": 500,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      }
    },
    {
      "id": "a1b2c3d4-0001-4000-8000-000000000011",
      "name": "Log Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [480, 120],
      "parameters": {
        "jsCode": "// Log incoming API request\nconst body = $input.first().json.body;\n\nconsole.log(JSON.stringify({\n  timestamp: new Date().toISOString(),\n  level: 'INFO',\n  module: 'API_Gateway',\n  event: 'REQUEST_RECEIVED',\n  data: {\n    key: body?.key,\n    schemaHash: body?.schemaHash,\n    chains: body?.chains,\n    includeAnalysis: body?.includeAnalysis\n  }\n}));\n\nreturn $input.all();"
      }
    }
  ],
  "connections": {
    "Webhook POST /api/query": {
      "main": [
        [
          { "node": "Log Request", "type": "main", "index": 0 },
          { "node": "Validate Input", "type": "main", "index": 0 }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          { "node": "Validation OK?", "type": "main", "index": 0 }
        ]
      ]
    },
    "Validation OK?": {
      "main": [
        [
          { "node": "Call GenericOrchestrator", "type": "main", "index": 0 }
        ],
        [
          { "node": "Respond 400 Bad Request", "type": "main", "index": 0 }
        ]
      ]
    },
    "Call GenericOrchestrator": {
      "main": [
        [
          { "node": "Orchestrator Success?", "type": "main", "index": 0 }
        ]
      ]
    },
    "Orchestrator Success?": {
      "main": [
        [
          { "node": "Format Success Response", "type": "main", "index": 0 }
        ],
        [
          { "node": "Format Error Response", "type": "main", "index": 0 }
        ]
      ]
    },
    "Format Success Response": {
      "main": [
        [
          { "node": "Respond 200 OK", "type": "main", "index": 0 }
        ]
      ]
    },
    "Format Error Response": {
      "main": [
        [
          { "node": "Respond 500 Error", "type": "main", "index": 0 }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "",
    "timezone": "UTC",
    "saveExecutionProgress": true
  },
  "staticData": null,
  "tags": [
    { "name": "chainmesh" },
    { "name": "api-gateway" },
    { "name": "module2" }
  ],
  "pinData": {},
  "versionId": "1.0.0",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "chainmesh-module2"
  }
}
